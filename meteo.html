<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√©t√©o Pastel</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Orbitron', monospace;
            background: #0a0a0a;
            color: #00ff41;
            min-height: 100vh;
            padding: 20px;
            background-image:
                radial-gradient(circle at 25% 25%, #ff006620 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, #00ff4120 0%, transparent 50%),
                linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            overflow-x: hidden;
            position: relative;
        }

        /* Scanlines */
        body::after {
            content: '';
            position: fixed; inset: 0;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,65,0.03) 2px, rgba(0,255,65,0.03) 4px);
            pointer-events: none; z-index: 1000;
        }

        .container { max-width: 1000px; margin: 0 auto; }

        .header { text-align: center; margin-bottom: 30px; animation: fadeInDown 0.8s ease-out; position: relative; }

        .title {
            font-size: 2.4rem;
            font-weight: 900;
            color: #00ff41;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 8px;
            text-shadow: 0 0 10px #00ff41, 0 0 20px #00ff4180, 0 0 40px #00ff4160;
        }

        .subtitle { font-size: 1rem; color: #ffff00; opacity: 0.9; text-shadow: 0 0 10px #ffff0080; letter-spacing: 1px; }

        .location-selector { margin-top: 22px; }

        .location-select {
            padding: 12px 18px;
            font-size: 0.95rem;
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            border: 1px solid #ffff00;
            color: #ffff00;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
            min-width: 240px;
            clip-path: polygon(10px 0%, 100% 0%, calc(100% - 10px) 100%, 0% 100%);
        }

        .location-select:hover {
            background: linear-gradient(135deg, #ffff0020, #ffff0010);
            box-shadow: 0 0 15px #ffff00, inset 0 0 15px #ffff0020;
            transform: translateY(-2px);
        }

        .location-select:focus {
            border-color: #00ff41;
            box-shadow: 0 0 12px #00ff4140, inset 0 0 12px #00ff4115;
        }

        .weather-card {
            background: linear-gradient(135deg, #1a1a1a, #0f0f0f);
            border: 2px solid #00ff41;
            clip-path: polygon(20px 0%, 100% 0%, calc(100% - 20px) 100%, 0% 100%);
            padding: 28px;
            margin-bottom: 24px;
            box-shadow: 0 10px 30px rgba(0,255,65,0.2), inset 0 0 20px rgba(0,255,65,0.08);
            animation: fadeInUp 0.8s ease-out 0.2s both;
            position: relative; overflow: hidden;
        }

        .weather-card::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, #00ff4120, transparent); transition: left .6s; }
        .weather-card:hover::before { left: 100%; }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .weather-now { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 16px; margin-bottom: 20px; }

        .weather-stat {
            background: linear-gradient(135deg, #2a2a2a, #1f1f1f);
            padding: 18px;
            text-align: center;
            border-left: 3px solid #ffff00;
            clip-path: polygon(15px 0%, 100% 0%, calc(100% - 15px) 100%, 0% 100%);
            transition: all 0.3s ease;
        }

        .weather-stat:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.15);
            border-left-color: #ff0066;
        }

        .weather-icon { font-size: 2rem; margin-bottom: 10px; display: block; filter: drop-shadow(0 0 6px #00ff41); }

        .weather-value { font-size: 1.4rem; font-weight: 900; color: #00ff41; margin-bottom: 4px; text-shadow: 0 0 10px #00ff4180; }

        .weather-label { font-size: 0.8rem; color: #ffff00; text-transform: uppercase; letter-spacing: 1px; }

        .forecast-section { margin-top: 24px; }

        .forecast-title { font-size: 1.3rem; font-weight: 900; color: #00ff41; margin-bottom: 14px; text-align: center; letter-spacing: 2px; text-shadow: 0 0 10px #00ff4180; }

        .forecast-hours { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 12px; }

        .forecast-hour {
            background: linear-gradient(135deg, #2a2a2a, #1f1f1f);
            padding: 16px 12px;
            text-align: center;
            border-left: 3px solid #ffff00;
            clip-path: polygon(15px 0%, 100% 0%, calc(100% - 15px) 100%, 0% 100%);
            transition: all 0.3s ease;
        }

        .forecast-hour:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.12);
            border-left-color: #ff0066;
        }

        .forecast-time { font-weight: 700; color: #ffff00; font-size: 0.9rem; margin-bottom: 8px; }

        .forecast-temp { font-size: 1.2rem; font-weight: 900; color: #00ff41; margin: 5px 0; text-shadow: 0 0 10px #00ff4180; }

        .forecast-desc { font-size: 0.8rem; color: #cccccc; line-height: 1.3; }

        .logs-section { background: linear-gradient(135deg, #1a1a1a, #0f0f0f); padding: 22px; border: 2px solid #00ff41; clip-path: polygon(20px 0%, 100% 0%, calc(100% - 20px) 100%, 0% 100%); box-shadow: 0 10px 30px rgba(0,255,65,0.15), inset 0 0 12px rgba(0,255,65,0.06); animation: fadeInUp 0.8s ease-out 0.4s both; }

        .logs-title { font-size: 1.1rem; font-weight: 900; color: #00ff41; margin-bottom: 12px; display: flex; align-items: center; gap: 10px; letter-spacing: 2px; text-transform: uppercase; text-shadow: 0 0 10px #00ff4180; }

        .logs { background: #111; padding: 16px; max-height: 150px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.85rem; color: #9ee2b1; line-height: 1.5; white-space: pre-wrap; border: 1px solid #00ff41; }

        .logs::-webkit-scrollbar { width: 6px; }

        .logs::-webkit-scrollbar-track { background: transparent; }

        .logs::-webkit-scrollbar-thumb { background: #00ff41; border-radius: 3px; }

        .error { background: linear-gradient(135deg, #2a0010, #1a000b); border: 2px solid #ff0066; color: #ff6a9a; padding: 16px; clip-path: polygon(15px 0%, 100% 0%, calc(100% - 15px) 100%, 0% 100%); text-align: center; font-weight: 700; }

        .loading { display: flex; justify-content: center; align-items: center; padding: 32px; flex-direction: column; gap: 16px; }

        .loading-spinner { width: 46px; height: 46px; border: 4px solid rgba(0,255,65,0.25); border-top: 4px solid #00ff41; border-radius: 50%; animation: spin 1s linear infinite; }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .loading-text { color: #ffff00; font-weight: 700; letter-spacing: 1px; }

        .refresh-btn {
            position: fixed; bottom: 30px; right: 30px; width: 60px; height: 60px;
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            border: 1px solid #ffff00; color: #ffff00;
            cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; font-size: 1.3rem;
            clip-path: polygon(14px 0%, 100% 0%, calc(100% - 14px) 100%, 0% 100%);
            box-shadow: 0 10px 30px rgba(0, 255, 65, 0.2), inset 0 0 20px rgba(0,255,65,0.08);
            animation: fadeInUp 0.8s ease-out 0.6s both;
        }

        .refresh-btn:hover { transform: translateY(-3px) scale(1.03); background: linear-gradient(135deg, #ffff0020, #ffff0010); box-shadow: 0 0 15px #ffff00, inset 0 0 15px #ffff0020; }

        .refresh-btn:active { transform: translateY(-2px) scale(1.01); }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .title {
                font-size: 1.8rem;
            }
            
            .weather-card {
                padding: 20px;
            }
            
            .weather-now {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .forecast-hours {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .refresh-btn {
                width: 52px; height: 52px;
                bottom: 20px;
                right: 20px;
            }

            .location-select {
                min-width: 200px; font-size: 0.9rem; padding: 10px 16px;
            }
        }

        .weather-status { text-align: center; margin-bottom: 20px; }

        .current-time { font-size: 1rem; font-weight: 700; color: #ffff00; margin-bottom: 8px; letter-spacing: 1px; }

        .location { font-size: 0.95rem; color: #00ff41; display: flex; align-items: center; justify-content: center; gap: 6px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">‚òÄÔ∏è M√©t√©o Douce</h1>
            <p class="subtitle">Pr√©visions m√©t√©orologiques en temps r√©el</p>
            
            <div class="location-selector">
                <select id="locationSelect" class="location-select" onchange="changeLocation()">
                    <option value="auto">üìç Ma position actuelle</option>
                    <option value="48.8566,2.3522">üóº Paris</option>
                    <option value="48.8049,2.1305">üëë Versailles</option>
                    <option value="46.6333,-1.3667">üåä Bournezeau (Vend√©e)</option>
                    <option value="48.6047,1.9858">üè° Orcemont</option>
                    <option value="48.6972,2.1878">üéì Orsay</option>
                </select>
            </div>
        </div>

        <div class="weather-card">
            <div id="weather">
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Chargement des donn√©es m√©t√©o...</div>
                </div>
            </div>
        </div>

        

        <button class="refresh-btn" onclick="refreshCurrentLocation()" title="Actualiser la m√©t√©o">
            üîÑ
        </button>
    </div>

    <script>
        const locations = {
            "48.8566,2.3522": "Paris",
            "48.8049,2.1305": "Versailles",
            "46.6333,-1.3667": "Bournezeau (Vend√©e)",
            "48.6047,1.9858": "Orcemont",
            "48.6972,2.1878": "Orsay"
        };

        const weatherCodes = {
            0: "Ciel clair",
            2: "Partiellement nuageux",
            3: "Couvert",
            45: "Brouillard",
            48: "Brume givr√©e",
            51: "Bruine l√©g√®re",
            53: "Bruine mod√©r√©e",
            55: "Bruine dense",
            56: "Bruine vergla√ßante l√©g√®re",
            57: "Bruine vergla√ßante dense",
            61: "Pluie faible",
            63: "Pluie mod√©r√©e",
            65: "Pluie forte",
            66: "Pluie verglacante faible",
            67: "Pluie vergla√ßante forte",
            71: "Neige faible",
            73: "Neige mod√©r√©e",
            75: "Neige forte",
            77: "Granules de neige",
            80: "Averses faibles",
            81: "Averses mod√©r√©es",
            82: "Averses fortes",
            85: "Averses de neige faibles",
            86: "Averses de neige fortes",
            95: "Orages",
            96: "Orages faibles",
            99: "Orages forts"
        };

        const weatherIcons = {
            0: "‚òÄÔ∏è", 2: "‚õÖ", 3: "‚òÅÔ∏è", 45: "üå´Ô∏è", 48: "üå´Ô∏è",
            51: "üå¶Ô∏è", 53: "üå¶Ô∏è", 55: "üå¶Ô∏è", 56: "üåßÔ∏è", 57: "üåßÔ∏è",
            61: "üåßÔ∏è", 63: "üåßÔ∏è", 65: "‚õàÔ∏è", 66: "üå®Ô∏è", 67: "üå®Ô∏è",
            71: "‚ùÑÔ∏è", 73: "‚ùÑÔ∏è", 75: "‚ùÑÔ∏è", 77: "‚ùÑÔ∏è",
            80: "üå¶Ô∏è", 81: "üå¶Ô∏è", 82: "‚õàÔ∏è", 85: "üå®Ô∏è", 86: "üå®Ô∏è",
            95: "‚õàÔ∏è", 96: "‚õàÔ∏è", 99: "‚õàÔ∏è"
        };

        function log(msg) {
            const timestamp = new Date().toLocaleTimeString('fr-FR');
            console.log(`[${timestamp}] ${msg}`);
        }

        // --- Config & helpers ---
        const LAST_LOC_KEY = 'weather:last_location';
        const LAST_LOC_TTL_MS = 7 * 24 * 3600 * 1000; // 7 jours
        const IPAPI_URL = 'https://ipapi.co/json/';

        function isSecureContextish() {
            try {
                const proto = location.protocol;
                const host = location.hostname;
                return (proto === 'https:') || host === 'localhost' || host === '127.0.0.1';
            } catch { return false; }
        }

        function saveLastLocation(loc) {
            try {
                localStorage.setItem(LAST_LOC_KEY, JSON.stringify({ ...loc, ts: Date.now() }));
                log('üíæ Position m√©moris√©e');
            } catch {}
        }

        function loadLastLocation() {
            try {
                const raw = localStorage.getItem(LAST_LOC_KEY);
                if (!raw) return null;
                const obj = JSON.parse(raw);
                if (!obj || typeof obj.lat !== 'number' || typeof obj.lon !== 'number') return null;
                if ((Date.now() - (obj.ts || 0)) > LAST_LOC_TTL_MS) return null;
                return obj;
            } catch { return null; }
        }

        function clearStoredLocation() {
            try { localStorage.removeItem(LAST_LOC_KEY); log('üóëÔ∏è Position m√©moris√©e effac√©e'); } catch {}
        }

        function parseUrlOverride() {
            try {
                const p = new URLSearchParams(location.search);
                const lat = parseFloat(p.get('lat'));
                const lon = parseFloat(p.get('lon'));
                const city = p.get('city') || 'Override URL';
                if (!Number.isNaN(lat) && !Number.isNaN(lon)) {
                    log('üîß Override URL d√©tect√© ‚Äî utilisation des coordonn√©es fournies');
                    return { lat, lon, city };
                }
            } catch {}
            return null;
        }

        async function getLocationByIP(timeoutMs = 5000) {
            log('üåê Tentative de localisation approximative via IP (ipapi.co)...');
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), timeoutMs);
            try {
                const res = await fetch(IPAPI_URL, { signal: ctrl.signal });
                clearTimeout(t);
                if (!res.ok) throw new Error('ipapi.co HTTP ' + res.status);
                const j = await res.json();
                const lat = parseFloat(j.latitude);
                const lon = parseFloat(j.longitude);
                const city = j.city || 'Localisation IP (ipapi.co)';
                if (Number.isFinite(lat) && Number.isFinite(lon)) {
                    log('‚úÖ Localisation IP obtenue via ipapi.co (pr√©cision limit√©e)');
                    return { lat, lon, city };
                }
                throw new Error('R√©ponse ipapi.co sans coordonn√©es');
            } catch (e) {
                log('‚ùå √âchec de la localisation IP ipapi.co: ' + (e.message || e));
                return null;
            }
        }

        async function getLocation() {
            log("üìç R√©cup√©ration de votre position...");
            // Permissions API pre-check (best-effort)
            if (navigator.permissions && navigator.permissions.query) {
                try {
                    const status = await navigator.permissions.query({ name: 'geolocation' });
                    if (status.state === 'denied') {
                        log("‚ùå Permission de localisation refus√©e par le navigateur");
                        return null;
                    }
                } catch (e) { /* ignore */ }
            }

            if (!("geolocation" in navigator)) {
                log("‚ö†Ô∏è G√©olocalisation non disponible sur cet appareil/navigateur");
                return null;
            }

            return new Promise((resolve) => {
                navigator.geolocation.getCurrentPosition(
                    pos => {
                        log("‚úÖ Position g√©ographique obtenue avec succ√®s");
                        resolve({
                            lat: pos.coords.latitude,
                            lon: pos.coords.longitude,
                            city: "Votre position"
                        });
                    },
                    error => {
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                log("‚ö†Ô∏è Acc√®s √† la g√©olocalisation refus√© par l‚Äôutilisateur");
                                break;
                            case error.POSITION_UNAVAILABLE:
                                log("‚ö†Ô∏è Service de localisation r√©seau indisponible (poss. 403)");
                                break;
                            case error.TIMEOUT:
                                log("‚ö†Ô∏è Temps d√©pass√© pour la r√©cup√©ration de la position");
                                break;
                            default:
                                log("‚ö†Ô∏è Erreur inconnue de g√©olocalisation");
                        }
                        resolve(null);
                    },
                    {
                        enableHighAccuracy: false,
                        timeout: 15000,
                        maximumAge: 600000 // 10 min
                    }
                );
            });
        }

        async function getWeather(lat, lon) {
            log("‚õÖ R√©cup√©ration des donn√©es m√©t√©orologiques...");
            try {
                const res = await fetch(
                    `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,weathercode&forecast_days=2&timezone=auto`
                );
                if (!res.ok) throw new Error(`Erreur HTTP: ${res.status}`);
                const data = await res.json();
                log("‚úÖ Donn√©es m√©t√©o re√ßues avec succ√®s");
                return data;
            } catch (e) {
                log("‚ùå Erreur lors de la r√©cup√©ration m√©t√©o : " + e.message);
                return null;
            }
        }

        function buildWeather(weather, location) {
            if (!weather || !weather.current_weather) {
                return '<div class="error">‚ùå Donn√©es m√©t√©orologiques indisponibles</div>';
            }

            const cur = weather.current_weather;
            const description = weatherCodes[cur.weathercode] || "Conditions inconnues";
            const icon = weatherIcons[cur.weathercode] || "üå§Ô∏è";
            
            const currentTime = new Date(cur.time).toLocaleString('fr-FR', {
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                hour: '2-digit',
                minute: '2-digit'
            });

            let html = `
                <div class="weather-status">
                    <div class="current-time">${currentTime}</div>
                    <div class="location">üìç ${location.city}</div>
                </div>
                
                <div class="weather-now">
                    <div class="weather-stat">
                        <span class="weather-icon">üå°Ô∏è</span>
                        <div class="weather-value">${cur.temperature}¬∞C</div>
                        <div class="weather-label">Temp√©rature</div>
                    </div>
                    <div class="weather-stat">
                        <span class="weather-icon">üí®</span>
                        <div class="weather-value">${cur.windspeed} km/h</div>
                        <div class="weather-label">Vent</div>
                    </div>
                    <div class="weather-stat">
                        <span class="weather-icon">${icon}</span>
                        <div class="weather-value" style="font-size: 1rem; line-height: 1.3;">${description}</div>
                        <div class="weather-label">Conditions</div>
                    </div>
                </div>

                <div class="forecast-section">
                    <h3 class="forecast-title">üïê Pr√©visions horaires</h3>
                    <div class="forecast-hours">
            `;

            // Afficher les 24 prochaines heures √† partir de maintenant
            const now = Date.now();
            const times = weather.hourly.time;
            let startIdx = times.findIndex(t => new Date(t).getTime() >= now);
            if (startIdx === -1) startIdx = 0;
            const maxCount = Math.min(24, times.length - startIdx);
            for (let k = 0; k < maxCount; k++) {
                const i = startIdx + k;
                const hour = new Date(times[i]).toLocaleTimeString('fr-FR', {
                    hour: "2-digit",
                    minute: "2-digit"
                });
                const temp = Math.round(weather.hourly.temperature_2m[i]);
                const code = weather.hourly.weathercode[i];
                const desc = weatherCodes[code] || "?";
                const hourIcon = weatherIcons[code] || "üå§Ô∏è";

                html += `
                    <div class="forecast-hour">
                        <div class="forecast-time">${hour}</div>
                        <div style="font-size: 1.5rem; margin: 8px 0;">${hourIcon}</div>
                        <div class="forecast-temp">${temp}¬∞C</div>
                        <div class="forecast-desc">${desc}</div>
                    </div>
                `;
            }

            html += "</div></div>";
            return html;
        }

        async function changeLocation() {
            const select = document.getElementById('locationSelect');
            const value = select.value;
            
            if (value === 'auto') {
                log("üîÑ Changement vers la position actuelle");
                loadWeather();
            } else {
                const [lat, lon] = value.split(',').map(Number);
                const cityName = locations[value];
                log(`üìç Changement de lieu vers ${cityName}`);
                
                const weatherElement = document.getElementById("weather");
                weatherElement.innerHTML = `
                    <div class="loading">
                        <div class="loading-spinner"></div>
                        <div class="loading-text">Chargement de ${cityName}...</div>
                    </div>
                `;
                
                try {
                    const weatherData = await getWeather(lat, lon);
                    weatherElement.innerHTML = buildWeather(weatherData, { city: cityName, lat, lon });
                    if (weatherData) saveLastLocation({ city: cityName, lat, lon });
                    log(`‚úÖ M√©t√©o de ${cityName} charg√©e avec succ√®s`);
                } catch (error) {
                    log("üí• Erreur lors du changement de lieu : " + error.message);
                    weatherElement.innerHTML = `
                        <div class="error">
                            ‚ùå Impossible de charger les donn√©es m√©t√©o.<br>
                            <small>V√©rifiez votre connexion internet et r√©essayez.</small>
                        </div>
                    `;
                }
            }
        }

        function useManualLocation() {
            const input = document.getElementById('manualLocation');
            const val = (input.value || '').trim();
            if (!val) { log('‚ÑπÔ∏è Entrez une ville ou des coordonn√©es lat,lon'); return; }
            const coordMatch = val.match(/^\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*$/);
            if (coordMatch) {
                const lat = parseFloat(coordMatch[1]);
                const lon = parseFloat(coordMatch[2]);
                log(`üß≠ Utilisation des coordonn√©es manuelles: ${lat},${lon}`);
                (async () => {
                    const weatherElement = document.getElementById("weather");
                    weatherElement.innerHTML = `
                        <div class="loading">
                            <div class="loading-spinner"></div>
                            <div class="loading-text">Chargement...</div>
                        </div>
                    `;
                    const data = await getWeather(lat, lon);
                    const loc = { city: 'Coordonn√©es manuelles', lat, lon };
                    weatherElement.innerHTML = buildWeather(data, loc);
                    if (data) saveLastLocation(loc);
                })();
                return;
            }
            // Essayer de mapper sur les lieux connus
            const found = Object.entries(locations).find(([, name]) => name.toLowerCase() === val.toLowerCase());
            if (found) {
                const [coords, cityName] = found;
                log(`üìç Lieu manuel reconnu: ${cityName}`);
                document.getElementById('locationSelect').value = coords;
                changeLocation();
                return;
            }
            log('‚ùì Entr√©e non reconnue. Utilisez un format "lat,lon" (ex: 48.8566,2.3522) ou un lieu connu.');
        }

        async function useIPFallback() {
            const weatherElement = document.getElementById("weather");
            weatherElement.innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Localisation IP et chargement m√©t√©o...</div>
                </div>
            `;
            const loc = await getLocationByIP();
            if (!loc) {
                weatherElement.innerHTML = `
                    <div class="error">
                        ‚ùå √âchec de la localisation IP.<br>
                        <small>Essayez le champ manuel ou choisissez un lieu dans la liste.</small>
                    </div>
                `;
                return;
            }
            const data = await getWeather(loc.lat, loc.lon);
            weatherElement.innerHTML = buildWeather(data, loc);
            if (data) saveLastLocation(loc);
            const notice = document.createElement('div');
            notice.className = 'location';
            notice.textContent = '‚ÑπÔ∏è Position approximative via IP ‚Äî pr√©cision limit√©e.';
            document.querySelector('.weather-card')?.appendChild(notice);
        }

        function retryWeather() { loadWeather(); }

        async function loadWeather() {
            const weatherElement = document.getElementById("weather");
            
            weatherElement.innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Actualisation en cours...</div>
                </div>
            `;

            try {
                log("üîÑ D√©marrage de l'actualisation m√©t√©o");
                // Secure-context messaging
                if (!isSecureContextish()) {
                    log('üîí Contexte non s√©curis√© d√©tect√© ‚Äî la g√©olocalisation n√©cessite HTTPS ou localhost');
                }

                // URL override has priority
                let locationOverride = parseUrlOverride();
                let location = locationOverride;

                // Direct IP-based fallback (skip native geolocation for rapidit√©)
                if (!location) {
                    const ipLoc = await getLocationByIP();
                    if (ipLoc) {
                        log('‚ÑπÔ∏è Utilisation de la localisation approximative via IP');
                        location = ipLoc;
                    }
                }

                // Last-known if still no location
                if (!location) {
                    const last = loadLastLocation();
                    if (last) {
                        const d = new Date(last.ts);
                        log(`üì¶ Utilisation de la derni√®re position connue (${d.toLocaleDateString('fr-FR')})`);
                        location = last;
                    }
                }

                // If still no location, neutral hint
                if (!location) {
                    weatherElement.innerHTML = `
                        <div style="text-align:center; padding:16px;">
                            <div style="margin-bottom:6px; font-weight:600;">S√©lectionnez un lieu dans le menu d√©roulant ci-dessus.</div>
                            <small>Astuce: vous pouvez choisir Paris, Versailles, etc.</small>
                        </div>
                    `;
                    log("‚ÑπÔ∏è Aucune position fournie ‚Äî inviter l'utilisateur √† choisir un lieu dans la liste");
                    return;
                }

                const weatherData = await getWeather(location.lat, location.lon);
                weatherElement.innerHTML = buildWeather(weatherData, location);
                if (weatherData) saveLastLocation(location);
                log("üéâ M√©t√©o mise √† jour avec succ√®s !");
            } catch (error) {
                log("üí• Erreur critique : " + error.message);
                weatherElement.innerHTML = `
                    <div class="error">
                        ‚ùå Impossible de charger les donn√©es m√©t√©o.<br>
                        <small>V√©rifiez votre connexion internet et r√©essayez.</small>
                    </div>
                `;
            }
        }

        function refreshCurrentLocation() {
            const select = document.getElementById('locationSelect');
            const value = select.value;
            
            if (value === 'auto') {
                log("üîÑ Actualisation de la position actuelle");
                loadWeather();
            } else {
                log("üîÑ Actualisation du lieu s√©lectionn√©");
                changeLocation();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            log("üöÄ Application m√©t√©o initialis√©e");
            loadWeather();
        });

        setInterval(() => {
            log("‚è∞ Actualisation automatique programm√©e");
            refreshCurrentLocation();
        }, 600000);
    </script>
</body>
</html>

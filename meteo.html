<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√©t√©o Pastel</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, 
                #ffeef8 0%, 
                #f0f4ff 25%, 
                #e8f5e8 50%, 
                #fff0e6 75%, 
                #f8f0ff 100%);
            min-height: 100vh;
            padding: 20px;
            color: #5a5a7a;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            animation: fadeInDown 1s ease-out;
        }

        .title {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, #ff9a9e, #a8e6cf, #ffd3a5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .subtitle {
            font-size: 1.2rem;
            font-weight: 300;
            color: #8e8ea8;
            opacity: 0.8;
        }

        .location-selector {
            margin-top: 30px;
        }

        .location-select {
            padding: 15px 25px;
            font-size: 1rem;
            font-family: 'Poppins', sans-serif;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(168, 230, 207, 0.5);
            border-radius: 25px;
            color: #5a5a7a;
            cursor: pointer;
            outline: none;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            min-width: 250px;
        }

        .location-select:hover {
            border-color: rgba(168, 230, 207, 0.8);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.08);
        }

        .location-select:focus {
            border-color: #a8e6cf;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1);
        }

        .weather-card {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px);
            border-radius: 30px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.05),
                0 0 0 1px rgba(255, 255, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: fadeInUp 1s ease-out 0.3s both;
            position: relative;
            overflow: hidden;
        }

        .weather-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(
                from 0deg,
                rgba(255, 154, 158, 0.1) 0deg,
                rgba(168, 230, 207, 0.1) 60deg,
                rgba(255, 211, 165, 0.1) 120deg,
                rgba(255, 154, 158, 0.1) 180deg,
                rgba(168, 230, 207, 0.1) 240deg,
                rgba(255, 211, 165, 0.1) 300deg,
                rgba(255, 154, 158, 0.1) 360deg
            );
            animation: rotate 20s linear infinite;
            z-index: -1;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .weather-now {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .weather-stat {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.8), 
                rgba(255, 255, 255, 0.4));
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            box-shadow: 
                0 10px 20px rgba(0, 0, 0, 0.02),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .weather-stat:hover {
            transform: translateY(-5px);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
        }

        .weather-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            display: block;
        }

        .weather-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #4a4a6a;
            margin-bottom: 5px;
        }

        .weather-label {
            font-size: 0.9rem;
            font-weight: 400;
            color: #8e8ea8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .forecast-section {
            margin-top: 40px;
        }

        .forecast-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #5a5a7a;
            margin-bottom: 20px;
            text-align: center;
        }

        .forecast-hours {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
        }

        .forecast-hour {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.6), 
                rgba(255, 255, 255, 0.2));
            border-radius: 20px;
            padding: 20px 15px;
            text-align: center;
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.03),
                inset 0 1px 0 rgba(255, 255, 255, 0.7);
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        .forecast-hour:hover {
            transform: translateY(-3px);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.8), 
                rgba(255, 255, 255, 0.4));
        }

        .forecast-time {
            font-weight: 600;
            color: #4a4a6a;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .forecast-temp {
            font-size: 1.2rem;
            font-weight: 700;
            color: #5a5a7a;
            margin: 5px 0;
        }

        .forecast-desc {
            font-size: 0.8rem;
            color: #8e8ea8;
            line-height: 1.3;
        }

        .logs-section {
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 
                0 10px 20px rgba(0, 0, 0, 0.03),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            animation: fadeInUp 1s ease-out 0.6s both;
        }

        .logs-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #5a5a7a;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logs {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 15px;
            padding: 20px;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #6a6a8a;
            line-height: 1.5;
            white-space: pre-wrap;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            scrollbar-width: thin;
            scrollbar-color: rgba(168, 230, 207, 0.5) transparent;
        }

        .logs::-webkit-scrollbar {
            width: 6px;
        }

        .logs::-webkit-scrollbar-track {
            background: transparent;
        }

        .logs::-webkit-scrollbar-thumb {
            background: rgba(168, 230, 207, 0.5);
            border-radius: 3px;
        }

        .error {
            background: linear-gradient(135deg, #ffd3d3, #ffe6e6);
            border: 1px solid rgba(255, 182, 182, 0.5);
            color: #8b5a5a;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            font-weight: 500;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
            flex-direction: column;
            gap: 20px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(168, 230, 207, 0.3);
            border-top: 4px solid #a8e6cf;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: #8e8ea8;
            font-weight: 500;
        }

        .refresh-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 30px;
            background: linear-gradient(135deg, #a8e6cf, #ffd3a5);
            border: none;
            cursor: pointer;
            box-shadow: 
                0 10px 20px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(255, 255, 255, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            animation: fadeInUp 1s ease-out 0.9s both;
        }

        .refresh-btn:hover {
            transform: translateY(-5px) scale(1.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .refresh-btn:active {
            transform: translateY(-2px) scale(1.05);
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .weather-card {
                padding: 25px;
            }
            
            .weather-now {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .forecast-hours {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .refresh-btn {
                width: 50px;
                height: 50px;
                bottom: 20px;
                right: 20px;
            }

            .location-select {
                min-width: 200px;
                font-size: 0.9rem;
                padding: 12px 20px;
            }
        }

        .weather-status {
            text-align: center;
            margin-bottom: 30px;
        }

        .current-time {
            font-size: 1.1rem;
            font-weight: 500;
            color: #6a6a8a;
            margin-bottom: 10px;
        }

        .location {
            font-size: 0.9rem;
            color: #8e8ea8;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">‚òÄÔ∏è M√©t√©o Douce</h1>
            <p class="subtitle">Pr√©visions m√©t√©orologiques en temps r√©el</p>
            
            <div class="location-selector">
                <select id="locationSelect" class="location-select" onchange="changeLocation()">
                    <option value="auto">üìç Ma position actuelle</option>
                    <option value="48.8566,2.3522">üóº Paris</option>
                    <option value="48.8049,2.1305">üëë Versailles</option>
                    <option value="46.6333,-1.3667">üåä Bournezeau (Vend√©e)</option>
                    <option value="48.6047,1.9858">üè° Orcemont</option>
                    <option value="48.6972,2.1878">üéì Orsay</option>
                </select>
            </div>
        </div>

        <div class="weather-card">
            <div id="weather">
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Chargement des donn√©es m√©t√©o...</div>
                </div>
            </div>
        </div>

        

        <button class="refresh-btn" onclick="refreshCurrentLocation()" title="Actualiser la m√©t√©o">
            üîÑ
        </button>
    </div>

    <script>
        const locations = {
            "48.8566,2.3522": "Paris",
            "48.8049,2.1305": "Versailles",
            "46.6333,-1.3667": "Bournezeau (Vend√©e)",
            "48.6047,1.9858": "Orcemont",
            "48.6972,2.1878": "Orsay"
        };

        const weatherCodes = {
            0: "Ciel clair",
            2: "Partiellement nuageux",
            3: "Couvert",
            45: "Brouillard",
            48: "Brume givr√©e",
            51: "Bruine l√©g√®re",
            53: "Bruine mod√©r√©e",
            55: "Bruine dense",
            56: "Bruine vergla√ßante l√©g√®re",
            57: "Bruine vergla√ßante dense",
            61: "Pluie faible",
            63: "Pluie mod√©r√©e",
            65: "Pluie forte",
            66: "Pluie verglacante faible",
            67: "Pluie vergla√ßante forte",
            71: "Neige faible",
            73: "Neige mod√©r√©e",
            75: "Neige forte",
            77: "Granules de neige",
            80: "Averses faibles",
            81: "Averses mod√©r√©es",
            82: "Averses fortes",
            85: "Averses de neige faibles",
            86: "Averses de neige fortes",
            95: "Orages",
            96: "Orages faibles",
            99: "Orages forts"
        };

        const weatherIcons = {
            0: "‚òÄÔ∏è", 2: "‚õÖ", 3: "‚òÅÔ∏è", 45: "üå´Ô∏è", 48: "üå´Ô∏è",
            51: "üå¶Ô∏è", 53: "üå¶Ô∏è", 55: "üå¶Ô∏è", 56: "üåßÔ∏è", 57: "üåßÔ∏è",
            61: "üåßÔ∏è", 63: "üåßÔ∏è", 65: "‚õàÔ∏è", 66: "üå®Ô∏è", 67: "üå®Ô∏è",
            71: "‚ùÑÔ∏è", 73: "‚ùÑÔ∏è", 75: "‚ùÑÔ∏è", 77: "‚ùÑÔ∏è",
            80: "üå¶Ô∏è", 81: "üå¶Ô∏è", 82: "‚õàÔ∏è", 85: "üå®Ô∏è", 86: "üå®Ô∏è",
            95: "‚õàÔ∏è", 96: "‚õàÔ∏è", 99: "‚õàÔ∏è"
        };

        function log(msg) {
            const timestamp = new Date().toLocaleTimeString('fr-FR');
            console.log(`[${timestamp}] ${msg}`);
        }

        // --- Config & helpers ---
        const LAST_LOC_KEY = 'weather:last_location';
        const LAST_LOC_TTL_MS = 7 * 24 * 3600 * 1000; // 7 jours
        const IPAPI_URL = 'https://ipapi.co/json/';

        function isSecureContextish() {
            try {
                const proto = location.protocol;
                const host = location.hostname;
                return (proto === 'https:') || host === 'localhost' || host === '127.0.0.1';
            } catch { return false; }
        }

        function saveLastLocation(loc) {
            try {
                localStorage.setItem(LAST_LOC_KEY, JSON.stringify({ ...loc, ts: Date.now() }));
                log('üíæ Position m√©moris√©e');
            } catch {}
        }

        function loadLastLocation() {
            try {
                const raw = localStorage.getItem(LAST_LOC_KEY);
                if (!raw) return null;
                const obj = JSON.parse(raw);
                if (!obj || typeof obj.lat !== 'number' || typeof obj.lon !== 'number') return null;
                if ((Date.now() - (obj.ts || 0)) > LAST_LOC_TTL_MS) return null;
                return obj;
            } catch { return null; }
        }

        function clearStoredLocation() {
            try { localStorage.removeItem(LAST_LOC_KEY); log('üóëÔ∏è Position m√©moris√©e effac√©e'); } catch {}
        }

        function parseUrlOverride() {
            try {
                const p = new URLSearchParams(location.search);
                const lat = parseFloat(p.get('lat'));
                const lon = parseFloat(p.get('lon'));
                const city = p.get('city') || 'Override URL';
                if (!Number.isNaN(lat) && !Number.isNaN(lon)) {
                    log('üîß Override URL d√©tect√© ‚Äî utilisation des coordonn√©es fournies');
                    return { lat, lon, city };
                }
            } catch {}
            return null;
        }

        async function getLocationByIP(timeoutMs = 5000) {
            log('üåê Tentative de localisation approximative via IP (ipapi.co)...');
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), timeoutMs);
            try {
                const res = await fetch(IPAPI_URL, { signal: ctrl.signal });
                clearTimeout(t);
                if (!res.ok) throw new Error('ipapi.co HTTP ' + res.status);
                const j = await res.json();
                const lat = parseFloat(j.latitude);
                const lon = parseFloat(j.longitude);
                const city = j.city || 'Localisation IP (ipapi.co)';
                if (Number.isFinite(lat) && Number.isFinite(lon)) {
                    log('‚úÖ Localisation IP obtenue via ipapi.co (pr√©cision limit√©e)');
                    return { lat, lon, city };
                }
                throw new Error('R√©ponse ipapi.co sans coordonn√©es');
            } catch (e) {
                log('‚ùå √âchec de la localisation IP ipapi.co: ' + (e.message || e));
                return null;
            }
        }

        async function getLocation() {
            log("üìç R√©cup√©ration de votre position...");
            // Permissions API pre-check (best-effort)
            if (navigator.permissions && navigator.permissions.query) {
                try {
                    const status = await navigator.permissions.query({ name: 'geolocation' });
                    if (status.state === 'denied') {
                        log("‚ùå Permission de localisation refus√©e par le navigateur");
                        return null;
                    }
                } catch (e) { /* ignore */ }
            }

            if (!("geolocation" in navigator)) {
                log("‚ö†Ô∏è G√©olocalisation non disponible sur cet appareil/navigateur");
                return null;
            }

            return new Promise((resolve) => {
                navigator.geolocation.getCurrentPosition(
                    pos => {
                        log("‚úÖ Position g√©ographique obtenue avec succ√®s");
                        resolve({
                            lat: pos.coords.latitude,
                            lon: pos.coords.longitude,
                            city: "Votre position"
                        });
                    },
                    error => {
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                log("‚ö†Ô∏è Acc√®s √† la g√©olocalisation refus√© par l‚Äôutilisateur");
                                break;
                            case error.POSITION_UNAVAILABLE:
                                log("‚ö†Ô∏è Service de localisation r√©seau indisponible (poss. 403)");
                                break;
                            case error.TIMEOUT:
                                log("‚ö†Ô∏è Temps d√©pass√© pour la r√©cup√©ration de la position");
                                break;
                            default:
                                log("‚ö†Ô∏è Erreur inconnue de g√©olocalisation");
                        }
                        resolve(null);
                    },
                    {
                        enableHighAccuracy: false,
                        timeout: 15000,
                        maximumAge: 600000 // 10 min
                    }
                );
            });
        }

        async function getWeather(lat, lon) {
            log("‚õÖ R√©cup√©ration des donn√©es m√©t√©orologiques...");
            try {
                const res = await fetch(
                    `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,weathercode&forecast_days=2&timezone=auto`
                );
                if (!res.ok) throw new Error(`Erreur HTTP: ${res.status}`);
                const data = await res.json();
                log("‚úÖ Donn√©es m√©t√©o re√ßues avec succ√®s");
                return data;
            } catch (e) {
                log("‚ùå Erreur lors de la r√©cup√©ration m√©t√©o : " + e.message);
                return null;
            }
        }

        function buildWeather(weather, location) {
            if (!weather || !weather.current_weather) {
                return '<div class="error">‚ùå Donn√©es m√©t√©orologiques indisponibles</div>';
            }

            const cur = weather.current_weather;
            const description = weatherCodes[cur.weathercode] || "Conditions inconnues";
            const icon = weatherIcons[cur.weathercode] || "üå§Ô∏è";
            
            const currentTime = new Date(cur.time).toLocaleString('fr-FR', {
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                hour: '2-digit',
                minute: '2-digit'
            });

            let html = `
                <div class="weather-status">
                    <div class="current-time">${currentTime}</div>
                    <div class="location">üìç ${location.city}</div>
                </div>
                
                <div class="weather-now">
                    <div class="weather-stat">
                        <span class="weather-icon">üå°Ô∏è</span>
                        <div class="weather-value">${cur.temperature}¬∞C</div>
                        <div class="weather-label">Temp√©rature</div>
                    </div>
                    <div class="weather-stat">
                        <span class="weather-icon">üí®</span>
                        <div class="weather-value">${cur.windspeed} km/h</div>
                        <div class="weather-label">Vent</div>
                    </div>
                    <div class="weather-stat">
                        <span class="weather-icon">${icon}</span>
                        <div class="weather-value" style="font-size: 1rem; line-height: 1.3;">${description}</div>
                        <div class="weather-label">Conditions</div>
                    </div>
                </div>

                <div class="forecast-section">
                    <h3 class="forecast-title">üïê Pr√©visions horaires</h3>
                    <div class="forecast-hours">
            `;

            // Afficher les 24 prochaines heures √† partir de maintenant
            const now = Date.now();
            const times = weather.hourly.time;
            let startIdx = times.findIndex(t => new Date(t).getTime() >= now);
            if (startIdx === -1) startIdx = 0;
            const maxCount = Math.min(24, times.length - startIdx);
            for (let k = 0; k < maxCount; k++) {
                const i = startIdx + k;
                const hour = new Date(times[i]).toLocaleTimeString('fr-FR', {
                    hour: "2-digit",
                    minute: "2-digit"
                });
                const temp = Math.round(weather.hourly.temperature_2m[i]);
                const code = weather.hourly.weathercode[i];
                const desc = weatherCodes[code] || "?";
                const hourIcon = weatherIcons[code] || "üå§Ô∏è";

                html += `
                    <div class="forecast-hour">
                        <div class="forecast-time">${hour}</div>
                        <div style="font-size: 1.5rem; margin: 8px 0;">${hourIcon}</div>
                        <div class="forecast-temp">${temp}¬∞C</div>
                        <div class="forecast-desc">${desc}</div>
                    </div>
                `;
            }

            html += "</div></div>";
            return html;
        }

        async function changeLocation() {
            const select = document.getElementById('locationSelect');
            const value = select.value;
            
            if (value === 'auto') {
                log("üîÑ Changement vers la position actuelle");
                loadWeather();
            } else {
                const [lat, lon] = value.split(',').map(Number);
                const cityName = locations[value];
                log(`üìç Changement de lieu vers ${cityName}`);
                
                const weatherElement = document.getElementById("weather");
                weatherElement.innerHTML = `
                    <div class="loading">
                        <div class="loading-spinner"></div>
                        <div class="loading-text">Chargement de ${cityName}...</div>
                    </div>
                `;
                
                try {
                    const weatherData = await getWeather(lat, lon);
                    weatherElement.innerHTML = buildWeather(weatherData, { city: cityName, lat, lon });
                    if (weatherData) saveLastLocation({ city: cityName, lat, lon });
                    log(`‚úÖ M√©t√©o de ${cityName} charg√©e avec succ√®s`);
                } catch (error) {
                    log("üí• Erreur lors du changement de lieu : " + error.message);
                    weatherElement.innerHTML = `
                        <div class="error">
                            ‚ùå Impossible de charger les donn√©es m√©t√©o.<br>
                            <small>V√©rifiez votre connexion internet et r√©essayez.</small>
                        </div>
                    `;
                }
            }
        }

        function useManualLocation() {
            const input = document.getElementById('manualLocation');
            const val = (input.value || '').trim();
            if (!val) { log('‚ÑπÔ∏è Entrez une ville ou des coordonn√©es lat,lon'); return; }
            const coordMatch = val.match(/^\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*$/);
            if (coordMatch) {
                const lat = parseFloat(coordMatch[1]);
                const lon = parseFloat(coordMatch[2]);
                log(`üß≠ Utilisation des coordonn√©es manuelles: ${lat},${lon}`);
                (async () => {
                    const weatherElement = document.getElementById("weather");
                    weatherElement.innerHTML = `
                        <div class="loading">
                            <div class="loading-spinner"></div>
                            <div class="loading-text">Chargement...</div>
                        </div>
                    `;
                    const data = await getWeather(lat, lon);
                    const loc = { city: 'Coordonn√©es manuelles', lat, lon };
                    weatherElement.innerHTML = buildWeather(data, loc);
                    if (data) saveLastLocation(loc);
                })();
                return;
            }
            // Essayer de mapper sur les lieux connus
            const found = Object.entries(locations).find(([, name]) => name.toLowerCase() === val.toLowerCase());
            if (found) {
                const [coords, cityName] = found;
                log(`üìç Lieu manuel reconnu: ${cityName}`);
                document.getElementById('locationSelect').value = coords;
                changeLocation();
                return;
            }
            log('‚ùì Entr√©e non reconnue. Utilisez un format "lat,lon" (ex: 48.8566,2.3522) ou un lieu connu.');
        }

        async function useIPFallback() {
            const weatherElement = document.getElementById("weather");
            weatherElement.innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Localisation IP et chargement m√©t√©o...</div>
                </div>
            `;
            const loc = await getLocationByIP();
            if (!loc) {
                weatherElement.innerHTML = `
                    <div class="error">
                        ‚ùå √âchec de la localisation IP.<br>
                        <small>Essayez le champ manuel ou choisissez un lieu dans la liste.</small>
                    </div>
                `;
                return;
            }
            const data = await getWeather(loc.lat, loc.lon);
            weatherElement.innerHTML = buildWeather(data, loc);
            if (data) saveLastLocation(loc);
            const notice = document.createElement('div');
            notice.className = 'location';
            notice.textContent = '‚ÑπÔ∏è Position approximative via IP ‚Äî pr√©cision limit√©e.';
            document.querySelector('.weather-card')?.appendChild(notice);
        }

        function retryWeather() { loadWeather(); }

        async function loadWeather() {
            const weatherElement = document.getElementById("weather");
            
            weatherElement.innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Actualisation en cours...</div>
                </div>
            `;

            try {
                log("üîÑ D√©marrage de l'actualisation m√©t√©o");
                // Secure-context messaging
                if (!isSecureContextish()) {
                    log('üîí Contexte non s√©curis√© d√©tect√© ‚Äî la g√©olocalisation n√©cessite HTTPS ou localhost');
                }

                // URL override has priority
                let locationOverride = parseUrlOverride();
                let location = locationOverride;

                // Direct IP-based fallback (skip native geolocation for rapidit√©)
                if (!location) {
                    const ipLoc = await getLocationByIP();
                    if (ipLoc) {
                        log('‚ÑπÔ∏è Utilisation de la localisation approximative via IP');
                        location = ipLoc;
                    }
                }

                // Last-known if still no location
                if (!location) {
                    const last = loadLastLocation();
                    if (last) {
                        const d = new Date(last.ts);
                        log(`üì¶ Utilisation de la derni√®re position connue (${d.toLocaleDateString('fr-FR')})`);
                        location = last;
                    }
                }

                // If still no location, neutral hint
                if (!location) {
                    weatherElement.innerHTML = `
                        <div style="text-align:center; padding:16px;">
                            <div style="margin-bottom:6px; font-weight:600;">S√©lectionnez un lieu dans le menu d√©roulant ci-dessus.</div>
                            <small>Astuce: vous pouvez choisir Paris, Versailles, etc.</small>
                        </div>
                    `;
                    log("‚ÑπÔ∏è Aucune position fournie ‚Äî inviter l'utilisateur √† choisir un lieu dans la liste");
                    return;
                }

                const weatherData = await getWeather(location.lat, location.lon);
                weatherElement.innerHTML = buildWeather(weatherData, location);
                if (weatherData) saveLastLocation(location);
                log("üéâ M√©t√©o mise √† jour avec succ√®s !");
            } catch (error) {
                log("üí• Erreur critique : " + error.message);
                weatherElement.innerHTML = `
                    <div class="error">
                        ‚ùå Impossible de charger les donn√©es m√©t√©o.<br>
                        <small>V√©rifiez votre connexion internet et r√©essayez.</small>
                    </div>
                `;
            }
        }

        function refreshCurrentLocation() {
            const select = document.getElementById('locationSelect');
            const value = select.value;
            
            if (value === 'auto') {
                log("üîÑ Actualisation de la position actuelle");
                loadWeather();
            } else {
                log("üîÑ Actualisation du lieu s√©lectionn√©");
                changeLocation();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            log("üöÄ Application m√©t√©o initialis√©e");
            loadWeather();
        });

        setInterval(() => {
            log("‚è∞ Actualisation automatique programm√©e");
            refreshCurrentLocation();
        }, 600000);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>To-Do List Minimaliste - Persistance ordre</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Orbitron', monospace;
      background: #0a0a0a;
      color: #00ff41;
      min-height: 100vh;
      padding: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-image:
        radial-gradient(circle at 25% 25%, #ff006620 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, #00ff4120 0%, transparent 50%),
        linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      overflow-x: hidden;
      position: relative;
    }

    /* Scanlines */
    body::after {
      content: '';
      position: fixed; inset: 0;
      background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,65,0.03) 2px, rgba(0,255,65,0.03) 4px);
      pointer-events: none; z-index: 1000;
    }

    h1 {
      font-size: 2rem; margin-bottom: 14px; font-weight: 900; color: #00ff41;
      text-transform: uppercase; letter-spacing: 3px;
      text-shadow: 0 0 10px #00ff41, 0 0 20px #00ff4180, 0 0 40px #00ff4160;
    }
    h1:hover { animation: glitch .3s; }

    .counter {
      margin-bottom: 18px; opacity: 0.9; color: #ffff00; letter-spacing: 1px;
      text-shadow: 0 0 10px #ffff0080;
    }

    form {
      width: 100%; max-width: 640px;
      display: flex; gap: 10px; margin-bottom: 24px;
      background: linear-gradient(135deg, #1a1a1a, #0f0f0f);
      border: 2px solid #00ff41;
      clip-path: polygon(20px 0%, 100% 0%, calc(100% - 20px) 100%, 0% 100%);
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0, 255, 65, 0.2), inset 0 0 20px rgba(0,255,65,0.08);
      animation: slideInUp .6s ease-out;
    }
    input[type="text"] {
      flex: 1; padding: 12px; background: #1a1a1a; border: 1px solid #333; color: #fff; outline: none;
      transition: all .3s ease; clip-path: polygon(10px 0%, 100% 0%, calc(100% - 10px) 100%, 0% 100%);
    }
    input[type="text"]:focus { border-color: #00ff41; box-shadow: 0 0 12px #00ff4140, inset 0 0 12px #00ff4115; background: #151515; }

    button {
      background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
      color: #ffff00; border: 1px solid #ffff00;
      padding: 12px 16px; cursor: pointer; font-weight: 900; text-transform: uppercase; letter-spacing: 2px;
      transition: all .3s ease; clip-path: polygon(10px 0%, 100% 0%, calc(100% - 10px) 100%, 0% 100%);
    }
    button:hover { background: linear-gradient(135deg, #ffff0020, #ffff0010); box-shadow: 0 0 15px #ffff00, inset 0 0 15px #ffff0020; transform: translateY(-2px); }

    ul {
      list-style: none; padding: 0; width: 100%; max-width: 640px; display: grid; gap: 14px;
    }
    li {
      padding: 12px; display: flex; align-items: center; gap: 10px; cursor: grab;
      background: linear-gradient(135deg, #2a2a2a, #1f1f1f);
      border-left: 3px solid #ffff00;
      clip-path: polygon(15px 0%, 100% 0%, calc(100% - 15px) 100%, 0% 100%);
      transition: transform .4s cubic-bezier(0.22, 1, 0.36, 1), box-shadow .4s cubic-bezier(0.22, 1, 0.36, 1), border-color .4s cubic-bezier(0.22, 1, 0.36, 1);
    }
    li:hover { transform: translateX(4px); box-shadow: 0 0 20px rgba(255,255,0,0.15); border-left-color: #ff0066; }
    li.dragging { opacity: 0.6; }
    li input[type="checkbox"] { transform: scale(1.1); accent-color: #00ff41; }
    li label { flex: 1; cursor: pointer; user-select: none; color: #00ff41; letter-spacing: .5px; }

    /* Edit button on hover (smooth reveal) */
    li { position: relative; }
    .edit-btn { display: inline-block; background: transparent; border: none; color: #ffff00; cursor: pointer; margin-left: 8px; font-size: 0.9rem; 
      opacity: 0; visibility: hidden; pointer-events: none; transform: translateY(2px) scale(0.96);
      transition: opacity .35s cubic-bezier(0.22, 1, 0.36, 1), transform .35s cubic-bezier(0.22, 1, 0.36, 1), visibility 0s linear .35s; }
    li:hover .edit-btn { opacity: 1; visibility: visible; pointer-events: auto; transform: translateY(0) scale(1); transition-delay: 0s; }
    .edit-btn:hover { transform: translateY(-1px) scale(1.02); }

    @media (max-width: 480px) {
      body { padding: 16px; }
      h1 { font-size: 1.6rem; letter-spacing: 2px; }
      form { padding: 12px; gap: 8px; }
      ul { gap: 10px; }
    }

    @keyframes slideInUp { from { opacity: 0; transform: translateY(40px) scale(0.98);} to { opacity: 1; transform: translateY(0) scale(1);} }
    @keyframes glitch { 0%{transform:translate(0);}20%{transform:translate(-2px,2px);}40%{transform:translate(-2px,-2px);}60%{transform:translate(2px,2px);}80%{transform:translate(2px,-2px);}100%{transform:translate(0);} }

    /* Filter select styling */
    #filter-tags {
      width: 100%;
      max-width: 640px;
      margin-bottom: 24px;
      padding: 12px;
      background: #1a1a1a;
      border: 2px solid #00ff41;
      color: #00ff41;
      font-family: 'Orbitron', monospace;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      clip-path: polygon(10px 0%, 100% 0%, calc(100% - 10px) 100%, 0% 100%);
      transition: all 0.3s ease;
      box-shadow: inset 0 0 12px rgba(0, 255, 65, 0.08);
      cursor: pointer;
    }

    #filter-tags:hover {
      background: #151515;
      box-shadow: 0 0 12px rgba(0, 255, 65, 0.15), inset 0 0 8px rgba(0, 255, 65, 0.1);
    }

    #filter-tags:focus {
      outline: none;
      border-color: #ffff00;
      box-shadow: 0 0 15px #ffff0050, inset 0 0 10px rgba(255, 255, 0, 0.15);
    }

    #filter-tags option {
      background: #0f0f0f;
      color: #00ff41;
      font-family: 'Orbitron', monospace;
    }
  </style>
  <!-- Use shared Supabase and auth helpers (consistent with the project) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="js/supabaseClient.js"></script>
  <script src="js/auth.js"></script>

    <script>
    // Configuration
    const TABLE = 'taaaches';
    let tasks = [];
    let completedCount = 0;
    let CURRENT_USER_ID = null;
    let completedTasks = [];
    // TAGS_MODE: 'array' -> column `tags` (array/json), 'csv' -> column `tag` (text), 'none' -> no tags column
    let TAGS_MODE = null;

    async function detectTagsMode() {
      if (TAGS_MODE) return TAGS_MODE;
      // Try `tags` first (array/json)
      try {
        const tryArray = await window.sb.from(TABLE).select('tags').limit(1);
        if (!tryArray.error) { TAGS_MODE = 'array'; return TAGS_MODE; }
      } catch (_) {}
      // Then try `tag` (single text)
      try {
        const tryCsv = await window.sb.from(TABLE).select('tag').limit(1);
        if (!tryCsv.error) { TAGS_MODE = 'csv'; return TAGS_MODE; }
      } catch (_) {}
      TAGS_MODE = 'none';
      return TAGS_MODE;
    }

    async function loadTasks() {
      if (!window.sb || !CURRENT_USER_ID) return;
      try {
        const mode = await detectTagsMode();
        const fields = mode === 'array' ? 'id, title, completed, "order", tags'
                     : mode === 'csv'   ? 'id, title, completed, "order", tag'
                                        : 'id, title, completed, "order"';
        const { data, error } = await window.sb
          .from(TABLE)
          .select(fields)
          .eq('user_id', CURRENT_USER_ID)
          .order('order', { ascending: true });

        if (error) throw error;
        const all = data || [];
        const mapTags = (row) => {
          if (mode === 'array') return Array.isArray(row.tags) ? row.tags : [];
          if (mode === 'csv') return typeof row.tag === 'string' && row.tag.length
            ? row.tag.split(',').map(s => s.trim()).filter(Boolean)
            : [];
          return [];
        };
        tasks = all.filter(t => !t.completed).map(row => ({ id: row.id, title: row.title, order: row.order, tags: mapTags(row) }));
        completedTasks = all.filter(t => t.completed).map(row => ({ id: row.id, title: row.title, order: row.order, tags: mapTags(row) }));
        completedCount = completedTasks.length;
        render();
      } catch (err) {
        console.error('[LOAD] Erreur:', err?.message || err);
      }

      // Edit button handler (active tasks only)
      document.querySelectorAll('#tasks .edit-btn').forEach(btn => {
        btn.onclick = async (e) => {
          const li = e.currentTarget.closest('li');
          const id = li?.dataset?.id;
          const label = li?.querySelector('label');
          const oldTitle = label ? label.textContent : '';
          const newTitle = window.prompt('Modifier la t√¢che :', oldTitle);
          const trimmed = (newTitle || '').trim();
          if (!id || !trimmed || trimmed === oldTitle) return;
          try {
            const { error } = await window.sb
              .from(TABLE)
              .update({ title: trimmed })
              .eq('id', id)
              .eq('user_id', CURRENT_USER_ID);
            if (error) throw error;
            loadTasks();
          } catch (err) {
            console.error('[EDIT] Erreur:', err?.message || err);
          }
        };
      });
    }

    function render() {
      const list = document.getElementById('tasks');
      const counter = document.getElementById('counter');
      counter.textContent = `T√¢ches termin√©es : ${completedCount}`;

      // Filter by selected tag (active tasks only)
      const filterEl = document.getElementById('filter-tags');
      const selectedTag = filterEl ? filterEl.value : '';
      const filteredTasks = selectedTag
        ? tasks.filter(t => Array.isArray(t.tags) && t.tags.includes(selectedTag))
        : tasks;

      // Generate tag options dynamically from all tasks (active + completed)
      if (filterEl) {
        const allTags = new Set();
        tasks.forEach(t => (t.tags || []).forEach(tag => allTags.add(tag)));
        completedTasks.forEach(t => (t.tags || []).forEach(tag => allTags.add(tag)));
        const current = filterEl.value;
        filterEl.innerHTML = '<option value="">Toutes les t√¢ches</option>' +
          Array.from(allTags)
            .sort((a,b) => a.localeCompare(b))
            .map(tag => `<option value="${tag}" ${current===tag?'selected':''}>${tag}</option>`) 
            .join('');
      }

      if (!filteredTasks.length) {
        list.innerHTML = '<li>Aucune t√¢che √† faire üéâ</li>';
      } else {
        list.innerHTML = filteredTasks.map(
          t => `
          <li draggable="true" data-id="${t.id}">
            <input type="checkbox" data-id="${t.id}">
            <label>${t.title}</label>
            <span class="tags">${Array.isArray(t.tags) && t.tags.length ? t.tags.join(', ') : ''}</span>
            <button class="edit-btn" type="button" aria-label="Editer la t√¢che">‚úèÔ∏è</button>
          </li>`
        ).join('');
      }

      // Checkbox handler ‚Üí mark completed
      document.querySelectorAll('#tasks input[type="checkbox"]').forEach(cb => {
        cb.onchange = async (e) => {
          const id = e.target.dataset.id;
          try {
            const { error } = await window.sb
              .from(TABLE)
              .update({ completed: true })
              .eq('id', id)
              .eq('user_id', CURRENT_USER_ID);
            if (error) throw error;
            loadTasks();
          } catch (err) {
            console.error('[UPDATE] Erreur:', err?.message || err);
          }
        };
      });

      // Drag & Drop
      setupDragAndDrop();

      // Completed list render (no drag & drop)
      const completedList = document.getElementById('completed-tasks');
      if (completedList) {
        if (!completedTasks.length) {
          completedList.innerHTML = '<li>Aucune t√¢che termin√©e üéâ</li>';
        } else {
          completedList.innerHTML = completedTasks.map(t => `
            <li data-id="${t.id}">
              <input type="checkbox" data-id="${t.id}" checked>
              <label>${t.title}</label>
              <span class=\"tags\">${Array.isArray(t.tags) && t.tags.length ? t.tags.join(', ') : ''}</span>
            </li>
          `).join('');

          // Checkbox handler ‚Üí un-complete
          completedList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.onchange = async (e) => {
              const id = e.target.dataset.id;
              try {
                const { error } = await window.sb
                  .from(TABLE)
                  .update({ completed: false })
                  .eq('id', id)
                  .eq('user_id', CURRENT_USER_ID);
                if (error) throw error;
                loadTasks();
              } catch (err) {
                console.error('[UNCOMPLETE] Erreur:', err?.message || err);
              }
            };
          });
        }
      }
    }

    async function addTask(title, tagsText) {
      if (!window.sb || !CURRENT_USER_ID) return;
      try {
        // find current max order
        const maxOrder = tasks.length ? Math.max(...tasks.map(t => t.order || 0)) : 0;
        const newOrder = maxOrder + 1;

        const tags = (tagsText || '').split(',').map(t => t.trim()).filter(Boolean);
        const mode = await detectTagsMode();
        const payload = { title, completed: false, order: newOrder, user_id: CURRENT_USER_ID };
        if (mode === 'array') payload.tags = tags;
        if (mode === 'csv') payload.tag = tags.join(', ');

        const { error } = await window.sb
          .from(TABLE)
          .insert([payload]);

        if (error) throw error;
        loadTasks();
      } catch (err) {
        console.error('[INSERT] Erreur:', err?.message || err);
      }
    }

    function setupDragAndDrop() {
      const list = document.getElementById('tasks');
      let dragging;

      list.querySelectorAll('li').forEach(li => {
        li.addEventListener('dragstart', () => {
          dragging = li;
          li.classList.add('dragging');
        });
        li.addEventListener('dragend', async () => {
          li.classList.remove('dragging');
          dragging = null;

          // Save new order to DB
          const ids = Array.from(list.children).map((li, i) => ({ id: li.dataset.id, pos: i + 1 }));
          try {
            for (const item of ids) {
              await window.sb
                .from(TABLE)
                .update({ order: item.pos })
                .eq('id', item.id)
                .eq('user_id', CURRENT_USER_ID);
            }
            loadTasks();
          } catch (err) {
            console.error('[REORDER] Erreur:', err);
          }
        });
        li.addEventListener('dragover', e => {
          e.preventDefault();
          const target = li;
          if (target === dragging) return;
          const rect = target.getBoundingClientRect();
          const next = (e.clientY - rect.top) / rect.height > 0.5;
          list.insertBefore(dragging, next ? target.nextSibling : target);
        });
      });
    }

    document.addEventListener('DOMContentLoaded', async () => {
      // Require auth and resolve current user id
      await AuthHelpers.requireAuth('login.html');
      const session = await AuthHelpers.getSession();
      CURRENT_USER_ID = session?.user?.id;

      document.getElementById('form').onsubmit = (e) => {
        e.preventDefault();
        const title = document.getElementById('content').value.trim();
        const tags = document.getElementById('tags').value.trim();
        if (title) addTask(title, tags);
        e.target.reset();
      };
      // Filter change -> re-render only
      const filterEl = document.getElementById('filter-tags');
      if (filterEl) {
        filterEl.addEventListener('change', () => render());
      }
      // Toggle completed section visibility
      const toggleBtn = document.getElementById('toggle-completed');
      const completedSection = document.getElementById('completed-section');
      if (toggleBtn && completedSection) {
        // Match spacing with list gap
        const tasksList = document.getElementById('tasks');
        if (tasksList) {
          const styles = window.getComputedStyle(tasksList);
          const gap = styles.getPropertyValue('gap') || styles.getPropertyValue('row-gap') || '14px';
          toggleBtn.style.marginTop = gap.trim();
        }
        toggleBtn.addEventListener('click', () => {
          const isHidden = completedSection.style.display === 'none';
          completedSection.style.display = isHidden ? 'block' : 'none';
          toggleBtn.textContent = isHidden ? 'Cacher t√¢ches termin√©es' : 'Afficher t√¢ches termin√©es';
        });
      }
      loadTasks();
    });
  </script>
</head>
<body>
  <h1>üìù To-Do List Minimaliste</h1>
  <div id="counter" class="counter">T√¢ches termin√©es : 0</div>
  <form id="form" autocomplete="off">
    <input type="text" id="content" placeholder="Nouvelle t√¢che..." />
    <input type="text" id="tags" placeholder="Tags (s√©par√©s par des virgules)" />
    <button type="submit">Ajouter</button>
  </form>
  <select id="filter-tags">
    <option value="">Toutes les t√¢ches</option>
  </select>
  <ul id="tasks"></ul>
  <button id="toggle-completed" type="button">Afficher t√¢ches termin√©es</button>
  <div id="completed-section" style="display:none">
    <h2>T√¢ches termin√©es</h2>
    <ul id="completed-tasks"></ul>
  </div>
</body>
</html>
